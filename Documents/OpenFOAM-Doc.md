





2022年03月19日20:47:45

# OpenFOAM documentary
https://www.openfoam.com/documentation/user-guide/4-mesh-generation-and-conversion

2022年03月20日20:46:26
# Chapter 1 Introduction
![图片](https://www.openfoam.com/documentation/userguide/img/user0x.png)
Figure 1.1: Overview of OpenFOAM structure.

2. The file structure of OpenFOAM cases is described in chapter 2
3. Running OpenFOAM applications is presented in chapter 3
4. Mesh generation is described in chapter 4
4. Chapter 5 provides details of the numerous models offered by OpenFOAM
5. Solving OpenFOAM cases is presented in chapter 6
6. Post-processing is described in chapter 7

For example, Chapter 4 Mesh generation and conversion
- section 4.1 gives an overview of the ways a mesh may be described in OpenFOAM; 
- section 4.3 covers the blockMesh utility for generating simple meshes of blocks of hexahedral cells; 
- section 4.4 covers the snappyHexMesh utility for generating complex meshes of hexahedral and split-hexahedral cells automatically from triangulated surface geometries; 
- section 4.5 describes the options available for conversion of a mesh that has been generated by a third-party product into a format that OpenFOAM can read.


2022年03月31日00:40:57

>但cfd.direct上的用户指南不太一样，好像文档更多一点。。https://cfd.direct/openfoam/user-guide/
- Introduction
- Tutorials
- Applications and libraries
- OpenFOAM cases
- Mesh generation and conversion
- Post-processing
- Models and physical properties

2022年03月31日19:10:02
# 2 OpenFOAM cases
One advantage of this is that the $FOAM_RUN environment variable is set to the directory $HOME/OpenFOAM/${USER}-v2006/run by default; the user can quickly move to that directory by executing a preset alias, run, at the command line.
## 2.1 File structure of OpenFOAM cases
The basic directory structure for a OpenFOAM case, that contains the minimum set of files required to run an application, is shown in Figure 2.1 and described as follows:
![图片](https://www.openfoam.com/documentation/userguide/img/user1x.png)
## 2.2 Basic input/output file format

### 2.2.1 General syntax rules
### 2.2.2 Dictionaries
OpenFOAM uses dictionaries as the most common means of specifying data. A dictionary is an entity that contains a set of data entries that can be retrieved by the I/O by means of keywords. 
### 2.2.3 The data file header
All data files that are read and written by OpenFOAM begin with a dictionary named `FoamFile` containing a standard set of keyword entries
### 2.2.4 Lists
OpenFOAM applications contain lists, e.g. a list of vertex coordinates for a mesh description. Lists are commonly found in I/O and have a format of their own in which the entries are contained within round braces `( )`.
### 2.2.5 Scalars, vectors and tensors
In OpenFOAM, a **tensor** is a `VectorSpace` of rank `2` and dimension `3` and therefore the data entries are always fixed to 9 real numbers.
This example demonstrates the way in which OpenFOAM ignores the line return is so that the entry can be written over multiple lines. It is treated no differently to listing the numbers on a single line:
   `( 1 0 0 0 1 0 0 0 1 )`
### 2.2.6 Dimensional units
As a safeguard against implementing a meaningless operation, OpenFOAM attaches dimensions to field data and physical properties and performs dimension checking on any tensor operation.
The I/O format for a dimensionSet is `7` scalars delimited by square brackets, e.g.
`[0 2 -1 0 0 0 0]`

No.	Property	SI unit	USCS unit
1	Mass	kilogram (kg)	pound-mass (lbm)
2	Length	metre (m)	foot (ft)
3	Time	
— — — — second (s) — — — —
4	Temperature	Kelvin (K)	degree Rankine (∘ \relax \special {t4ht=R)
5	Quantity	kilogram-mole (kgmol)	pound-mole (lbmol)
6	Current	
— — — — ampere (A) — — — —
7	Luminous intensity	
— — — — candela (cd) — — — —

### 2.2.7 Dimensioned types
Physical properties are typically specified with their associated dimensions. These entries have the format that the following example of a `dimensionedScalar` demonstrates:
    `nu             [0 2 -1 0 0 0 0]  1`;
The first `nu` is the keyword; the next entry is the `dimensionSet` and the final entry is the `scalar` value.

### 2.2.8 Fields

Much of the I/O data in OpenFOAM are tensor fields, e.g. velocity, pressure data, that are read from and written into the time directories. OpenFOAM writes field data using keyword entries as described in Table 2.3.
### 2.2.9 Directives and macro substitutions
There is additional file syntax that offers great flexibility for the setting up of OpenFOAM case files, namely directives and macro substitutions. Directives are commands that can be contained within case files that begin with the hash (#) symbol. Macro substitutions begin with the dollar ($) symbol.
### 2.2.10 The #include and #inputMode directives
if a user has a set of cases that require the same RAS turbulence model settings, a single file can be created with those settings which is simply included in the `turbulenceProperties` file of each case. Macro substitutions can extend well beyond a single value so that, for example, sets of boundary conditions can be predefined and called by a single macro. The extent to which such functionality can be used is almost endless.
### 2.2.11 The #codeStream directive
The #codeStream directive takes C++ code which is compiled and executed to deliver the dictionary entry. The code and compilation instructions are specified through the following keywords.


# Chapter 3 Running applications
Applications are split into two main categories:
- solvers

that are each designed to solve a specific problem in computational continuum mechanics;
+ utilities

that perform simple pre-and post-processing tasks, mainly involving data manipulation and algebraic calculations.

OpenFOAM is divided into a set of precompiled libraries that are dynamically linked during compilation of the solvers and utilities. Libraries such as those for physical models are supplied as source code so that users may conveniently add their own models to the libraries. This chapter gives an overview of **solvers, utilities and libraries, their creation, modification, compilation and execution**.


## 3.1 Running applications
Each application is designed to be executed from a terminal command line, typically reading and writing a set of data files associated with a particular case. The data files for a case are stored in a directory named after the case as described in section 2.1; the directory name with full path is here given the generic name \<`caseDir`\>.
### 3.1.1 Command line options
Starting from OpenFOAM v1706 the set of command line options can be readily obtained by `command-line completion`. 
### 3.1.2 Running in the background
Like any UNIX/Linux executable, applications can be run as a background process, i.e. one which does not have to be completed before the user can give the shell additional commands. If the user wished to run the blockMesh example as a background process and output the case progress to a log file, they could enter:
`blockMesh > log &`

## 3.2 Running applications in parallel
The method of parallel computing used by OpenFOAM is known as domain decomposition, in which the geometry and associated fields are broken into pieces and allocated to separate processors for solution. The process of parallel computation involves: 
- decomposition of mesh and fields; 
- running the application in parallel; 
- and, post-processing the decomposed case as described in the following sections. 

The parallel running uses the public domain openMPI implementation of the standard message passing interface (MPI).

### 3.2.1 Decomposition of mesh and initial field data
The mesh and fields are decomposed using the `decomposePar utility`. The underlying aim is to break up the domain with minimal effort but in such a way to guarantee a fairly economic solution. The geometry and fields are broken up according to a set of parameters specified in a dictionary named `decomposeParDict` that must be located in the `system` directory of the case of interest.
The user has a choice of four methods of decomposition, specified by the method keyword as described below. `simple, hierarchical, scotch, manual`.

### 3.2.2 Running a decomposed case
A decomposed OpenFOAM case is run in parallel using the `openMPI` implementation of MPI.
`openMPI` can be run on a local multiprocessor machine very simply but when running on machines across a network, a file must be created that contains the host names of the machines. The file can be given any name and located at any path. In the following description we shall refer to such a file by the generic name, including full path, \<`machines`\>.

### 3.2.3 Distributing data across several disks
Data files may need to be distributed if, for example, if only local disks are used in order to improve performance. In this case, the user may find that the root path to the case directory may differ between machines. The paths must then be specified in the `decomposeParDict` dictionary using `distributed` and `roots` keywords.

### 3.2.4 Post-processing parallel processed cases
When post-processing cases that have been run in parallel the user can:

- reconstruct the mesh and field data to recreate the complete domain and fields, which can be post-processed as normal;
- post-process each segment of decomposed domain individually; or
- use ParaView via the option paraFoam -vtk and select the decomposedCase from the GUI whereby the case will be assembled internally

### 
### 
### 

## 


---

Test:
```python
fun (x: Int, y: Int): Int {
  return x + y
}
```


表头|条目一|条目二
:---:|:---:|:---:
项目|项目一|项目二
项目|项目一|项目二
项目|项目一|项目二
项目|项目一|项目二




[TOC]


























